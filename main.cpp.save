#include <iostream>
#include <allegro5/allegro.h>
#include <allegro5/allegro_font.h>
#include <allegro5/allegro_ttf.h>
#include <allegro5/allegro_native_dialog.h>
#include <allegro5/allegro_primitives.h>
#include <allegro5/allegro_image.h>
#include <allegro5/allegro_audio.h>
#include <allegro5/allegro_acodec.h>
#include <stdio.h>
#include <cmath>

using namespace std;

/*#include "src/Globals.h"
#include "src/CError.h"
#include "src/CAllegro.h"
#include "src/CCollision.h"
#include "src/CGameState.h"
#include "src/CButton.h"
#include "src/CProgram.h"*/


                /**************************************
               **            ZOMBIELAND V4            **
              ***       @author Valentin Soulas       ***
             ****  @contact soulasvalentin@gmail.com  ****
             ****                                     ****
              ***         UTN GENERAL PACHECO         ***
               **     LABORATORIO II - TSP (2015)     **
                **************************************/

/**
   BUGS CONOCIDOS
   - Al guardar una partida, esta podrá ser cargada solo si no se
     cerró el programa desde que se guardó la partida. Si se quiere
     cargar una partida de una sesión del programa anterior, se
     carga con datos corruptos.
*/


/**
    ESTRUCTURA

    inicializar();
    while(control){
        leer_inputs();
        if("60 veces x segundo){
            actualizar();
            renderizar();
        }
    }
    destruir();

    Video tutoriales recomendados
    https://www.youtube.com/playlist?list=PL9333715188CD7669
    https://www.youtube.com/playlist?list=PL39C639F833BEB5E4
*/
/*
int main()
{


    //-------------------------------
    //  INICIALIZAR ALLEGRO
    //-------------------------------

    Allegro al(1024,768);
    al.install_addons();
    al.load_fonts();
    al.load_samples();
    al.register_events();
    al_start_timer(timer);
    imagen("resources/menus/intro_zombieland.jpg",true);
    al.load_bitmaps();

    srand(time(NULL));

    CProgram Program;


    ///*********************************************
    ///*          COMIENZO DEL PROGRAMA
    ///*********************************************

    while(GameState.getState() != EXIT){

        ///*********************************************
        ///*        PROCESO DEL PROGRAMA
        ///*********************************************

        al_wait_for_event(event_queue, &ev);
        if(ev.type == ALLEGRO_EVENT_TIMER) GameState.changeRedraw(true);

        al.read_mouse_coords();

        Program.update_actual_state(GameState.getState());

        Error.update_error();


        ///*********************************************
        ///*        RENDERIZADO DEL PROGRAMA
        ///*********************************************

        if(GameState.getRedraw() and al_is_event_queue_empty(event_queue)){

            GameState.changeRedraw(false);

            Program.render_actual_state(GameState.getState());

            Error.render_error();

            if(GameState.getDebug_info()){
                al.showMousePos(x_mouse+camx,y_mouse+camy);
                al.showFps();
                GameState.show_state_debug();
            }

            al_flip_display();
            al_clear_to_color(al_map_rgb(20,20,20));
        }
    }

    ///*********************************************
    ///*            DESTRIUR EL JUEGO
    ///*********************************************

    Program.destroy_all();
    al.terminate_allegro();

    return 0;
}

*/




int width = 1280;
int height = 1024;
float gravity = 2;

struct Sprite
{
	float x;
	float y;
	float velX;
	float velY;
	int dirX;
	int dirY;

	int maxFrame;
	int curFrame;
	int frameCount;
	int frameDelay;
	int frameWidth;
	int frameHeight;
	int animationColumns;
	int animationDirection;
};

void InitSprites(Sprite &sprite);
void UpdateSprites(Sprite &sprite);
void DrawSprites(Sprite &sprite);
void AttractParticles(Sprite sprite[], int numSprites);
double AngleToTarget(double x1, double y1, double x2, double y2);

int main(void)
{
	//variables
	srand(time(NULL));
	bool done = false;
	bool render = false;
	float gameTime = 0;
	int frames = 0;
	int gameFPS = 0;

	const int numSprites = 50;

	Sprite orbs[numSprites];

	//allegro variable
	ALLEGRO_DISPLAY *display = NULL;
	ALLEGRO_EVENT_QUEUE *event_queue = NULL;
	ALLEGRO_TIMER *timer;
	ALLEGRO_FONT *font18 = NULL;

	//program init
	if (!al_init())										//initialize Allegro
		return -1;

	display = al_create_display(800, 600);			//create our display object

	if (!display)										//test display object
		return -1;

	//addon init
	al_install_keyboard();
	al_init_font_addon();
	al_init_ttf_addon();

	font18 = al_load_font("fonts/KeepCalm-Medium.ttf", 12, 0);


	for (int i = 0; i < numSprites; i++)
		InitSprites(orbs[i]);

	event_queue = al_create_event_queue();
	timer = al_create_timer(1.0 / 60);

	al_register_event_source(event_queue, al_get_timer_event_source(timer));
	al_register_event_source(event_queue, al_get_keyboard_event_source());

	al_start_timer(timer);
	gameTime = al_current_time();
	while (!done)
	{
		ALLEGRO_EVENT ev;
		al_wait_for_event(event_queue, &ev);

		if (ev.type == ALLEGRO_EVENT_KEY_DOWN)
		{
			switch (ev.keyboard.keycode)
			{
			case ALLEGRO_KEY_ESCAPE:
				done = true;
				break;
			case ALLEGRO_KEY_LEFT:

				break;
			case ALLEGRO_KEY_RIGHT:

				break;
			case ALLEGRO_KEY_UP:

				break;
			case ALLEGRO_KEY_DOWN:

				break;
			}
		}
		else if (ev.type == ALLEGRO_EVENT_TIMER)
		{
			frames++;
			if (al_current_time() - gameTime >= 1)
			{
				gameTime = al_current_time();
				gameFPS = frames;
				frames = 0;
			}

			AttractParticles(orbs, numSprites);

			for (int i = 0; i < numSprites; i++)
				UpdateSprites(orbs[i]);

			render = true;
		}

		if (render && al_is_event_queue_empty(event_queue))
		{
			render = false;

			for (int i = 0; i < numSprites; i++)
				DrawSprites(orbs[i]);

			al_draw_textf(font18, al_map_rgb(255, 0, 255), 5, 5, 0, "FPS: %i", gameFPS);
			al_flip_display();
			al_clear_to_color(al_map_rgb(0, 0, 0));
		}
	}

	al_destroy_font(font18);
	al_destroy_event_queue(event_queue);
	al_destroy_display(display);						//destroy our display object

	return 0;
}

void InitSprites(Sprite &sprite)
{
	sprite.x = rand() % 200 + 100;
	sprite.y = rand() % 200 + 100;
	sprite.velX = rand() % 5 + 2;
	sprite.velY = rand() % 5 + 2;
	sprite.dirX = -1;
	sprite.dirY = -1;

	sprite.maxFrame = 71;
	sprite.curFrame = 0;
	sprite.frameCount = 0;
	sprite.frameDelay = 5;
	sprite.frameWidth = 64;
	sprite.frameHeight = 64;
	sprite.animationColumns = 16;
	sprite.animationDirection = 1;
}
void UpdateSprites(Sprite &sprite)
{
	if (++sprite.frameCount >= sprite.frameDelay)
	{
		sprite.curFrame += sprite.animationDirection;
		if (sprite.curFrame >= sprite.maxFrame)
			sprite.curFrame = 0;
		else if (sprite.curFrame <= 0)
			sprite.curFrame = sprite.maxFrame - 1;

		sprite.frameCount = 0;
	}

	sprite.x += sprite.velX;
	sprite.y += sprite.velY;

	if ((sprite.x <= 0) ||
		(sprite.x >= width - sprite.frameWidth))
	{
		sprite.velX *= -1;
		sprite.animationDirection *= -1;
	}
	if ((sprite.y <= 0) ||
		(sprite.y >= height - sprite.frameHeight))
	{
		sprite.velY *= -1;
		sprite.animationDirection *= -1;
	}
}
void DrawSprites(Sprite &sprite)
{
	int fx = (sprite.curFrame % sprite.animationColumns) * sprite.frameWidth;
	int fy = (sprite.curFrame / sprite.animationColumns) * sprite.frameHeight;

	al_draw_filled_circle(sprite.x, sprite.y, 4, al_map_rgb(0, 200, 200));
}
void AttractParticles(Sprite sprite[], int numSprites)
{
	for (int i = 0; i < numSprites; i++)
	{
		float dvx = 0;
		float dvy = 0;
		for (int j = 0; j < numSprites; j++)
		{

			if (i != j)
			{
				float angle = AngleToTarget(sprite[i].x, sprite[i].y, sprite[j].x, sprite[j].y);
				dvy += (gravity * sin(angle)) / 1000;
				dvx += (gravity * cos(angle)) / 1000;

			}

		}
		sprite[i].velX += dvx;
		sprite[i].velY += dvy;
	}
}

double AngleToTarget(double x1, double y1, double x2, double y2)
{
	double deltaX = (x2 - x1);
	double deltaY = (y2 - y1);
	return atan2(deltaY, deltaX);
}



















